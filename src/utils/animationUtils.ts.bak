// Animation utilities for smooth transitions and visual feedback
export interface AnimationConfig {
  duration: number;
  easing: string;
  delay?: number;
}

export const ANIMATION_CONFIGS = {
  // State change animations
  modeSwitch: {
    duration: 300,
    easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
    delay: 0
  },
  toolSwitch: {
    duration: 250,
    easing: 'ease-out',
    delay: 0
  },
  // User interaction animations
  drag: {
    duration: 0,
    easing: 'linear',
    delay: 0
  },
  hover: {
    duration: 200,
    easing: 'ease-out',
    delay: 0
  },
  // Loading animations
  loading: {
    duration: 1000,
    easing: 'linear',
    delay: 0
  },
  // Mathematical computation animations
  matrixChange: {
    duration: 500,
    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
    delay: 50
  },
  eigenvalueCalculation: {
    duration: 800,
    easing: 'cubic-bezier(0.23, 1, 0.32, 1)',
    delay: 100
  },
  // Enhanced animations for smooth transitions
  vectorTransformation: {
    duration: 600,
    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    delay: 0
  },
  matrixElementChange: {
    duration: 300,
    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
    delay: 0
  },
  gridTransformation: {
    duration: 700,
    easing: 'cubic-bezier(0.23, 1, 0.32, 1)',
    delay: 100
  },
  basisVectorChange: {
    duration: 550,
    easing: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
    delay: 75
  },
  determinantUpdate: {
    duration: 400,
    easing: 'cubic-bezier(0.23, 1, 0.32, 1)',
    delay: 50
  },
  colorThemeTransition: {
    duration: 350,
    easing: 'ease-in-out',
    delay: 0
  }
} as const;

// CSS class generators for consistent animations
export const generateTransitionClasses = (config: AnimationConfig) => {
  const { duration, easing, delay = 0 } = config;
  return `transition-all duration-${duration} ${easing}${delay > 0 ? ` delay-${delay}` : ''}`;
};

// Enhanced Animation state management for canvas elements
export class CanvasAnimationManager {
  private animationFrameId: number | null = null;
  private isAnimating = false;
  private animationCallbacks = new Set<() => void>();
  
  startAnimation(callback: () => void, duration: number = 16): void {
    this.animationCallbacks.add(callback);
    
    if (!this.isAnimating) {
      this.isAnimating = true;
      const animate = () => {
        this.animationCallbacks.forEach(cb => cb());
        this.animationFrameId = requestAnimationFrame(animate);
      };
      
      this.animationFrameId = requestAnimationFrame(animate);
      
      // Auto-stop after duration for finite animations
      if (duration > 0) {
        setTimeout(() => this.stopAnimation(), duration);
      }
    }
  }
  
  stopAnimation(callback?: () => void): void {
    if (callback) {
      this.animationCallbacks.delete(callback);
    } else {
      this.animationCallbacks.clear();
    }
    
    if (this.animationCallbacks.size === 0) {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.isAnimating = false;
    }
  }
  
  isRunning(): boolean {
    return this.isAnimating;
  }
}

// Enhanced Spring physics for smooth value interpolation
export class SpringAnimator {
  private currentValue: number;
  private targetValue: number;
  private velocity: number;
  private stiffness: number;
  private damping: number;
  private onUpdateCallback?: (value: number) => void;
  
  constructor(initialValue: number, stiffness = 0.1, damping = 0.8) {
    this.currentValue = initialValue;
    this.targetValue = initialValue;
    this.velocity = 0;
    this.stiffness = stiffness;
    this.damping = damping;
  }
  
  setTarget(value: number): void {
    this.targetValue = value;
  }
  
  setOnUpdate(callback: (value: number) => void): void {
    this.onUpdateCallback = callback;
  }
  
  update(): number {
    const force = (this.targetValue - this.currentValue) * this.stiffness;
    this.velocity += force;
    this.velocity *= this.damping;
    this.currentValue += this.velocity;
    
    if (this.onUpdateCallback) {
      this.onUpdateCallback(this.currentValue);
    }
    
    return this.currentValue;
  }
  
  isAtRest(threshold = 0.001): boolean {
    return Math.abs(this.currentValue - this.targetValue) < threshold &&
           Math.abs(this.velocity) < threshold;
  }
  
  getCurrentValue(): number {
    return this.currentValue;
  }
  
  reset(value: number): void {
    this.currentValue = value;
    this.targetValue = value;
    this.velocity = 0;
  }
}

// Enhanced Matrix transition animator for smooth matrix transformations
export class MatrixTransitionAnimator {
  private fromMatrix: number[][];
  private toMatrix: number[][];
  private currentMatrix: number[][];
  private progress: number = 0;
  private isAnimating = false;
  private onUpdateCallback?: (matrix: number[][]) => void;
  private onCompleteCallback?: () => void;
  private duration: number;
  private startTime: number = 0;
  private easingFunction: keyof typeof easingFunctions;
  
  constructor(
    initialMatrix: number[][],
    duration = 500,
    easing: keyof typeof easingFunctions = 'easeOut'
  ) {
    this.fromMatrix = this.cloneMatrix(initialMatrix);
    this.toMatrix = this.cloneMatrix(initialMatrix);
    this.currentMatrix = this.cloneMatrix(initialMatrix);
    this.duration = duration;
    this.easingFunction = easing;
  }
  
  private cloneMatrix(matrix: number[][]): number[][] {
    return matrix.map(row => [...row]);
  }
  
  setTarget(targetMatrix: number[][]): void {
    this.fromMatrix = this.cloneMatrix(this.currentMatrix);
    this.toMatrix = this.cloneMatrix(targetMatrix);
    this.progress = 0;
    this.startTime = performance.now();
    this.isAnimating = true;
  }
  
  setOnUpdate(callback: (matrix: number[][]) => void): void {
    this.onUpdateCallback = callback;
  }
  
  setOnComplete(callback: () => void): void {
    this.onCompleteCallback = callback;
  }
  
  update(): number[][] {
    if (!this.isAnimating) return this.currentMatrix;
    
    const elapsed = performance.now() - this.startTime;
    this.progress = Math.min(elapsed / this.duration, 1);
    
    const easedProgress = easingFunctions[this.easingFunction](this.progress);
    
    this.currentMatrix = interpolateMatrix2D(
      this.fromMatrix,
      this.toMatrix,
      easedProgress,
      this.easingFunction
    );
    
    if (this.onUpdateCallback) {
      this.onUpdateCallback(this.currentMatrix);
    }
    
    if (this.progress >= 1) {
      this.isAnimating = false;
      if (this.onCompleteCallback) {
        this.onCompleteCallback();
      }
    }
    
    return this.currentMatrix;
  }
  
  isActive(): boolean {
    return this.isAnimating;
  }
  
  getCurrentMatrix(): number[][] {
    return this.currentMatrix;
  }
  
  skip(): void {
    this.currentMatrix = this.cloneMatrix(this.toMatrix);
    this.progress = 1;
    this.isAnimating = false;
    if (this.onCompleteCallback) {
      this.onCompleteCallback();
    }
  }
}

// Enhanced Vector transition animator
export class VectorTransitionAnimator {
  private fromVectors: { x: number; y: number }[];
  private toVectors: { x: number; y: number }[];
  private currentVectors: { x: number; y: number }[];
  private progress: number = 0;
  private isAnimating = false;
  private onUpdateCallback?: (vectors: { x: number; y: number }[]) => void;
  private onCompleteCallback?: () => void;
  private duration: number;
  private startTime: number = 0;
  private easingFunction: keyof typeof easingFunctions;
  
  constructor(
    initialVectors: { x: number; y: number }[],
    duration = 600,
    easing: keyof typeof easingFunctions = 'easeOut'
  ) {
    this.fromVectors = [...initialVectors];
    this.toVectors = [...initialVectors];
    this.currentVectors = [...initialVectors];
    this.duration = duration;
    this.easingFunction = easing;
  }
  
  setTarget(targetVectors: { x: number; y: number }[]): void {
    this.fromVectors = [...this.currentVectors];
    this.toVectors = [...targetVectors];
    this.progress = 0;
    this.startTime = performance.now();
    this.isAnimating = true;
  }
  
  setOnUpdate(callback: (vectors: { x: number; y: number }[]) => void): void {
    this.onUpdateCallback = callback;
  }
  
  setOnComplete(callback: () => void): void {
    this.onCompleteCallback = callback;
  }
  
  update(): { x: number; y: number }[] {
    if (!this.isAnimating) return this.currentVectors;
    
    const elapsed = performance.now() - this.startTime;
    this.progress = Math.min(elapsed / this.duration, 1);
    
    const easedProgress = easingFunctions[this.easingFunction](this.progress);
    
    this.currentVectors = this.fromVectors.map((fromVector, i) => 
      interpolateVector2D(fromVector, this.toVectors[i] || fromVector, easedProgress, this.easingFunction)
    );
    
    if (this.onUpdateCallback) {
      this.onUpdateCallback(this.currentVectors);
    }
    
    if (this.progress >= 1) {
      this.isAnimating = false;
      if
